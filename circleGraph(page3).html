<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        #canvasText {
            width: 270px;
            height: 270px;
            display: inline-block;
            position: absolute;
            top: 10%;
            left: 10%;
        }
        
        #canvasShadow {
            width: 270px;
            height: 270px;
            display: inline-block;
            position: absolute;
            top: 10%;
            left: 10%;
        }
    </style>
</head>

<body>

    <canvas id="canvasShadow" width="540" height="540"></canvas>
    <canvas id="canvasText" width="540" height="540"></canvas>

    <script>
        var recommendSizeData = {
            recommendSize: 'M',
            isCorrectGender: true,
            recommendRate: 0,
            status: true,
            sizes: ['XS', 'S', 'M', 'L', 'XL']
        }

        var elIds = {
            canvasShadow: 'canvasShadow',
            canvasText: 'canvasText'
        }

        var recommendedSizeData = {
            sizeRate: recommendSizeData.recommendRate,
            sizeName: recommendSizeData.recommendSize,
            totalSizes: recommendSizeData.sizes
        };

        function getRecommendSizeList(totalSizeList, selectedSize) {
            var recommendedSizeList = [];

            var listAdd = "";
            var sizeListLength = totalSizeList.length;
            var minCount = 0;
            var maxCount = 0;

            for (var i = 0; i < sizeListLength; i++) {
                if (totalSizeList[i] == selectedSize) {
                    selectIndex = i;
                }
            }

            if (selectIndex < 3 && sizeListLength < 5) {
                minCount = 0;
                maxCount = sizeListLength - 1;
            } else if (selectIndex < 3 && sizeListLength > 4) {
                maxCount = 4;
            } else if (selectIndex == 3 && sizeListLength == 4) {
                maxCount = selectIndex;
            } else if (selectIndex == sizeListLength - 1) {
                minCount = selectIndex - 4;
                maxCount = selectIndex;
            } else if (selectIndex == sizeListLength - 2) {
                minCount = selectIndex - 3;
                maxCount = selectIndex + 1;
            } else if (sizeListLength > 4) {
                minCount = selectIndex - 2;
                maxCount = selectIndex + 2;
            }

            for (var i = minCount; i <= maxCount; i++) {
                recommendedSizeList.push(totalSizeList[i]);
            }
            return recommendedSizeList;
        };

        function initCircleGraph(canvas) {
            var shadowCanvas = document.getElementById(canvas.canvasShadow);
            var textCanvas = document.getElementById(canvas.canvasText);
            var textContext = textCanvas.getContext("2d");
            var shadowContext = shadowCanvas.getContext("2d");

            var circleGraphControl = {
                motionValue: 200,
                shadowBlurGene: 60,
                textSize: 16 * 2,
                textColor: '#F6F5F3',
                BrightTextColor: '#20607A',
                pointerText: 'ME!',
                pointerSize: 14 * 2,
                pointerTextColor: '#00FFB0',
                circleColor: '#ffffff',
                shadowReversalIn: false,
                shadowReversalOut: true
            }

            return {
                textCanvas: textCanvas,
                textContext: textContext,
                shadowCanvas: shadowCanvas,
                shadowContext: shadowContext,
                circleGraphControl: circleGraphControl
            };
        };

        function calCircleGraphLocation(canvasInfo, sizeList, recommendedSize, recommendedSizeRate) {
            var c = canvasInfo || {};

            var canvasHalfWidth = c.shadowCanvas.width / 2;
            var recommendedSizeIndex = sizeList.indexOf(recommendedSize);
            var piePieceAllMotion = 18 * c.circleGraphControl.motionValue;
            var piePieceMotion = 5 * c.circleGraphControl.motionValue;
            var drawRadian = ((2 * Math.PI) / piePieceAllMotion) * piePieceMotion;
            var calculatedsizeIndex = (Math.PI / 18) * (recommendedSizeIndex * 6 + 3);

            var radius = c.textCanvas.height / 2;
            var pointerRadius = c.textCanvas.height / 4;
            var sizeIndexValue = sizeList.indexOf(recommendedSize);
            var sizeListLength = sizeList.length - 1;
            var sizeLocationValue = (sizeIndexValue + 1) * 3;
            var circleLocation = sizeLocationValue + 6;

            return {
                canvas: c.shadowCanvas,
                shadowContext: c.shadowContext,
                textContext: c.textContext,
                canvasHalfWidth: canvasHalfWidth,
                drawRadian: drawRadian,
                radius: radius,
                pointerRadius: pointerRadius,
                calculatedsizeIndex: calculatedsizeIndex,
                sizeIndexValue: sizeIndexValue,
                sizeListLength: sizeListLength,
                sizeLocationValue: sizeLocationValue,
                circleLocation: circleLocation,
                sizeList: sizeList,
                recommendedSizeRate: recommendedSizeRate,
            };
        }

        function drawCircleGraphShadow(canvasInfo, locationValueInfo) {
            var l = locationValueInfo || {};
            var t = canvasInfo.circleGraphControl || {};
            var stratPoint;
            var startValue = 0.4;
            var blurIncrease = 0;

            if (l.recommendedSizeRate >= 3) {
                startValue += 0.1;
            } else if (l.recommendedSizeRate <= -3) {
                startValue -= 0.1;
            }
            stratPoint = (startValue * Math.PI) + l.calculatedsizeIndex;

            var pieGraphInterval = setInterval(function () {
                l.shadowContext.clearRect(0, 0, l.canvas.width, l.canvas.height);

                l.shadowContext.beginPath();
                l.shadowContext.moveTo(l.canvasHalfWidth, l.canvasHalfWidth);
                l.shadowContext.arc(l.canvasHalfWidth, l.canvasHalfWidth, l.canvasHalfWidth / 1.35, stratPoint, stratPoint + l.drawRadian, t.shadowReversalIn);
                l.shadowContext.shadowColor = "rgba(32,96,122," + blurIncrease + ")";
                l.shadowContext.shadowBlur = t.shadowBlurGene;
                l.shadowContext.closePath();
                l.shadowContext.fillStyle = t.circleColor;
                l.shadowContext.fill();

                l.shadowContext.beginPath();
                l.shadowContext.moveTo(l.canvasHalfWidth, l.canvasHalfWidth);
                l.shadowContext.arc(l.canvasHalfWidth, l.canvasHalfWidth, l.canvasHalfWidth / 1.35, stratPoint, stratPoint + l.drawRadian, t.shadowReversalOut);
                l.shadowContext.shadowColor = "rgba(227,237,168," + blurIncrease + ")";
                l.shadowContext.shadowBlur = t.shadowBlurGene;
                l.shadowContext.fillStyle = t.circleColor;
                l.shadowContext.fill();

                l.shadowContext.beginPath();
                l.shadowContext.arc(l.canvasHalfWidth, l.canvasHalfWidth, l.canvasHalfWidth - 70, 0, 2 * Math.PI);
                l.shadowContext.shadowBlur = 0;
                l.shadowContext.fillStyle = t.circleColor;
                l.shadowContext.fill();

                blurIncrease += 0.05;

                if (blurIncrease > 1) {
                    clearInterval(pieGraphInterval);
                }
            }, t.motionValue);
        };

        function drawRecommendSizeText(canvasInfo, locationValueInfo) {
            var l = locationValueInfo || {};
            var t = canvasInfo.circleGraphControl || {};
            var s = this;

            s.drawCircleGraphText = function () {
                var labelCount = 0;
                l.textContext.translate(l.radius, l.radius);
                l.radius = l.radius * 0.79;

                l.textContext.beginPath();
                l.textContext.arc(0, 0, l.radius / 1.06, 0, 2 * Math.PI);
                l.textContext.fillStyle = t.circleColor;
                l.textContext.fill();

                l.textContext.font = "" + t.textSize + "px arial";
                l.textContext.textAlign = "center";

                for (var i = 12; i < 25; i++) {
                    var sizeNameValue = i - 9;
                    var textAngle = i * Math.PI / 9;

                    l.textContext.rotate(textAngle);
                    l.textContext.translate(0, -l.radius * 0.8);
                    l.textContext.rotate(-textAngle);
                    l.textContext.fillStyle = t.textColor;
                    if (sizeNameValue % 3 == 0) {
                        l.textContext.fillText(l.sizeList[labelCount], 0, 0);
                        labelCount++;
                    } else if (sizeNameValue % 3 !== 0) {
                        l.textContext.fillText(".", 0, 0);
                    }

                    l.textContext.rotate(textAngle);
                    l.textContext.translate(0, l.radius * 0.8);
                    l.textContext.rotate(-textAngle);
                }
            };

            s.drawColorText = function () {
                var indexIncrease = 0;
                var locationValueIncrease = 0;
                var textRange = 3;

                var brightColorText = setInterval(function () {
                    var circleLocationValue = l.circleLocation - 9;
                    var lightTextAngle = l.circleLocation * Math.PI / 9;

                    if (l.recommendedSizeRate >= 3) {
                        locationValueIncrease = +1;
                    } else if (l.recommendedSizeRate <= -3) {
                        locationValueIncrease = -1;
                    }

                    l.textContext.rotate(lightTextAngle);
                    l.textContext.translate(0, -l.radius * 0.8);
                    l.textContext.rotate(-lightTextAngle);

                    if (circleLocationValue > l.sizeLocationValue + locationValueIncrease - textRange && circleLocationValue < l.sizeLocationValue + locationValueIncrease + textRange) {

                        if (circleLocationValue >= textRange && circleLocationValue <= 15) {

                            if (circleLocationValue % textRange == 0) {
                                l.textContext.clearRect(-25, -15, 50, 30);
                                l.textContext.fillStyle = t.BrightTextColor;
                                if (l.recommendedSizeRate >= textRange) {
                                    l.textContext.fillText(l.sizeList[l.sizeIndexValue + indexIncrease], 0, 0);
                                    indexIncrease++;
                                } else if (l.recommendedSizeRate <= -textRange) {
                                    indexIncrease--;
                                    l.textContext.fillText(l.sizeList[l.sizeIndexValue + indexIncrease], 0, 0);
                                    indexIncrease += 2;
                                } else {
                                    l.textContext.fillText(l.sizeList[l.sizeIndexValue + indexIncrease], 0, 0);
                                }

                            } else if (circleLocationValue % textRange !== 0) {
                                l.textContext.clearRect(-lightTextAngle, -lightTextAngle, 20, 20);
                                l.textContext.fillStyle = t.BrightTextColor;
                                l.textContext.fillText(".", 0, 0);
                            }
                        }
                    }

                    l.textContext.rotate(lightTextAngle);
                    l.textContext.translate(0, l.radius * 0.8);
                    l.textContext.rotate(-lightTextAngle);

                    l.circleLocation++;

                    if (circleLocationValue == l.sizeLocationValue + textRange) {
                        s.drawPointerText();
                    } else if (circleLocationValue == l.sizeLocationValue + textRange + 1) {
                        clearInterval(brightColorText);
                        s.drawBrightPointerText();
                    }
                }, t.motionValue);

            };

            s.drawPointerText = function () {
                var sizeRateValue = 0;

                l.textContext.font = "" + t.pointerSize + "px arial";
                l.textContext.textAlign = "center";
                l.textContext.fillStyle = t.pointerTextColor;

                for (var i = 6; i < 25; i++) {

                    if (l.recommendedSizeRate >= 3 && l.sizeIndexValue !== l.sizeListLength) {
                        sizeRateValue = 0.4;
                    } else if (l.recommendedSizeRate <= -3 && l.sizeIndexValue !== 0) {
                        sizeRateValue = -0.4;
                    } else {
                        sizeRateValue = 0;
                    }

                    var pointerSizeNameValue = i - 9;
                    var pointerAngle = i * Math.PI / 9 + sizeRateValue;

                    l.textContext.rotate(pointerAngle);
                    l.textContext.translate(0, -l.pointerRadius * 1.8);
                    l.textContext.rotate(-pointerAngle);

                    if (pointerSizeNameValue % 3 == 0 && pointerSizeNameValue / 3 == l.sizeIndexValue + 1) {
                        l.textContext.fillText(t.pointerText, 0, 5);
                    }

                    l.textContext.rotate(pointerAngle);
                    l.textContext.translate(0, l.pointerRadius * 1.8);
                    l.textContext.rotate(-pointerAngle);
                }
            };

            s.drawBrightPointerText = function () {

                l.circleLocation -= 5;
                var lightOnTextAngle = l.circleLocation * Math.PI / 9;

                l.textContext.rotate(lightOnTextAngle);
                l.textContext.translate(0, -l.radius * 0.8);
                l.textContext.rotate(-lightOnTextAngle);
                l.textContext.clearRect(-25, -15, 50, 30);
                l.textContext.font = "" + t.textSize + "px arial";
                l.textContext.fillStyle = t.pointerTextColor;
                l.textContext.fillText(l.sizeList[l.sizeIndexValue], 0, 0);
            };

            s.drawCircleGraphText();
            s.drawColorText();
        };

        function drawCircleGraph() {
            var canvasInfo = initCircleGraph(elIds);
            var selectedSizeList = getRecommendSizeList(recommendedSizeData.totalSizes, recommendedSizeData.sizeName);
            var circleGraphLocationValue = calCircleGraphLocation(canvasInfo, selectedSizeList, recommendedSizeData.sizeName, recommendedSizeData.sizeRate);

            drawCircleGraphShadow(canvasInfo, circleGraphLocationValue);
            drawRecommendSizeText(canvasInfo, circleGraphLocationValue);
        }

        drawCircleGraph();
    </script>
</body>

</html>